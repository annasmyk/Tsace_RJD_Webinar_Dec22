---
title: |
 | Using JDemetra+ in R: from version 2 to version 3 
 | Presentation 2: Seasonal adjustment in R
subtitle: "TSACE Webinar, Wednesday December 14th 2022"
author: "Anna Smyk and Tanguy Barthelemy"
division: |
    | With the collaboration of Alain Quartier-la-tente
    | 
logo: "img/SACElogo"
automaticcontents: true
automaticcontentstext: "Contents"
output:
    beamer_presentation:
        template: template_Beamer.tex
        keep_tex: yes
        theme: TorinoTh
        slide_level: 3
        includes:
          in_header: preamble_beamer.tex
themeoptions: "coding=utf8,language=english"
classoption: 'usepdftitle=false,french' #handout
fontsize: 10pt
bibliography: [biblio.bib]
biblio-style: unsrtnat
natbiboptions: [numbers]
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      cache = F, 
                      fig.align = 'center',
                      fig.path = "img/markdown-")
library(knitr)
library(kableExtra)
library(microbenchmark)
library(ggplot2)
library(RJDemetra)
library(rjd3toolkit)
library(rjd3modelling)
library(rjd3sa)
library(rjd3arima)
library(rjd3x13)
library(rjd3tramoseats)
library(rjdemetra3)
library(ggdemetra3)

# library(rjd3sts)
# library(rjd3highfreq)

# library(rjd3bench)
fig.ext <- "pdf"
is_html <- knitr::is_html_output()
is_latex <- knitr::is_latex_output()
fig.ext = "pdf"
if(is_html){
    fa_arrow_circle_right <- '<i class="fas fa-arrow-circle-right"></i>'
    fa_r_project <- '<i class="fab fa-r-project"></i>'
}else {
    if(is_latex){
        fa_arrow_circle_right <- "\\faIcon{arrow-circle-right}"
        fa_r_project <- "\\faIcon{r-project}"
        fa_java <- "\\faIcon{java}"
    }else {
        fa_arrow_circle_right <- "->"
        fa_r_project <- 'R'
    }
}
options(width = 60)
def.par <- par(no.readonly = TRUE)
```

```{r, eval=TRUE, echo=FALSE}
ipi<-read.csv2("Data/IPI_nace4.csv")
ipi$date<-as.Date(ipi$date,format="%d/%m/%Y")
ipi[,-1]<-sapply(ipi[,-1],as.numeric)
# creating a TS object from a data frame 
y_raw<-ts(ipi[,"RF3030"],frequency=12,start=c(1990,1),end=c(2019,6))
y_new<-ts(ipi[,"RF3030"],frequency=12,start=c(1990,1),end=c(2019,9))


```

# Introduction 

### Outline table 

### Data formats

here, no workspace structure 
- assets
- shortcomings 


### SA process 

- testing for seasonality 
- pre treatement 
- create customisezd variables for pretratement
- decomposition 
- output series 
- diagnostics 
- customize parameters 
- repeat..



### rjd3 suite of packages for SA

in v2 : 

in v3: more tools (tests,...)


# X13 (...and some Tramo-seats)

## Quick Launch with default specifications 

### Quick Launch with default specifications (1)

specifications 
- x13
- regarima 
- x11 (one less spec in default x13)

- Specification: created with `spec_x11_default()`, `spec_x13_default()`, `spec_regarima_default()` 

spec_regarima_default(name = c("rg4", "rg0", "rg1", "rg2c", "rg3", "rg5c"))

spec_x13_default(name = c("rsa4", "rsa0", "rsa1", "rsa2c", "rsa3", "rsa5c"))

spec_x11_default()

### Quick Launch with default specifications (2)

- Apply model with `x11()`, `x13()`, `fast.x13()`, `regarima()`, `fast.regarima()`

### Running SA estimation process {.allowframebreaks} 

In version 2
\footnotesize
```{r,eval=TRUE, include=TRUE}
# X13
sa_x13_v2<-RJDemetra::x13(y_raw, spec ="RSA5c")

#Tramo-Seats
sa_ts_v2<-RJDemetra::tramoseats(y_raw, spec ="RSAfull")
```

In version 3
\footnotesize
```{r,eval=TRUE, include=TRUE}
#X13
sa_x13_v3 <- rjd3x13::x13(y_raw, spec= "RSA5")
sa_x13_v3

#Tramo seats
sa_ts_v3 <- rjd3tramoseats::tramoseats(y_raw, spec= "RSAfull")

```

### Running only pre-adjustment
In version 2
\footnotesize
```{r,eval=TRUE, include=TRUE}
# Reg-Arima part from X13 only (different default spec names, cf help pages)
regA_v2<-RJDemetra::regarima_x13(y_raw, spec ="RG5c")

# Tramo only 
tramo_v2<-RJDemetra::regarima_tramoseats(y_raw,
  spec = "TRfull")
```

In version 3
\footnotesize
```{r,eval=TRUE, include=TRUE}
#X13
sa_regarima_v3 <- rjd3x13::regarima(y_raw)

#Tramo seats 
sa_tramo_v3 <- rjd3tramoseats::tramo(y_raw)

# "fast." versions...(cf output structure)
```

### Running only decomposition

In version 2
\footnotesize
```{r,eval=TRUE, include=TRUE}
# X11 (spec option)
X11_v2<-RJDemetra::x13(y_raw, spec ="X11")

#Tramo-Seats ? you 
#sa_ts_v2<-RJDemetra::tramoseats(y_raw, spec ="RSAfull")
```

In version 3
\footnotesize
```{r,eval=TRUE, include=TRUE}
#X11
x11_v3 <- rjd3x13::x11(y_raw)

#Tramo seats
#sa_ts_v3 <- rjd3tramoseats::seats.decompose(y_raw)

```

## Rerieving output and data visualization

### Output structure  v2
show the list of lists
do a new version 

### Output structure  v3 (cf txt file)
show the NEW list of lists

### Differences from version 2 to version 3

Differences: 
- specs
- results: more specific ()
- specs direct accessible + 2 concepts
(spec in v12 was point spec;, more about this in refresh section)

### Retrieve output series 

Input and output  = TS in R objects (not when using specific extensions for HF data)
- final series : different 
\footnotesize
```{r,eval=TRUE, include=TRUE}
# Version 2 (affichage main, d tables in user def output)
sa_x13_v2$final$series
sa_x13_v2$final$forecasts

# Version 3 
# final seasonally adjusted series
sa_x13_v3$result$final$d11final


```

In version 3 much more series are available without using the user-defined output option.

### Series from preadjustement

```{r,eval=TRUE, include=TRUE}
# Version 2 (affichage main, d tables in user def output)
sa_x13_v2$regarima$model$effects # data frame

# forecast accessible only via user defined output (cf below)

# Version 3: "x11 names" : preadjustement effets as stored in the A table
# add doc on names   
sa_x13_v3$result$preadjust$a6


```

### Series from decompostion

In version 2
- D tables accessible via user-defined output,
- forecast series accessible only via user defined output (cf below)

In  Version 3: "x11 names" 
\footnotesize
```{r,eval=FALSE, include=TRUE}
# Version 3  
sa_x13_v3$result$decomposition$d5 # tables from D1 to D13
```


### Retrieving Diagnostics

Just fetch the needed objects in the relevant part of the output structure or print the whole "model"

```{r,eval=TRUE, include=TRUE}
# Version 2 
print(sa_x13_v2)
sa_x13_v2$decomposition$mstats
sa_x13_v2$decomposition$s_filter
sa_x13_v2$decomposition$t_filter

# version 3 (more diagnostics available by default)
print(sa_x13_v2)
sa_x13_v3$result$diagnostics$td.ftest.i
```
What is missing (series or diagnostics) can be retrieved adding user-defined output in the options 


### Retrieving user defined-output (1/2)

In version 2 or version 3: first define a vector of objects your wish to add

Lists of avaible diagnostics or series 
\footnotesize

```{r,eval=FALSE, include=TRUE}
# Version 2 
user_defined_variables("X13-ARIMA") 
user_defined_variables("TRAMO-SEATS")
# Version 3: more specific functions 
userdefined_variables_tramoseats("tramoseats")
userdefined_variables_tramoseats("tramo") # restriction

userdefined_variables_x13("regarima") #restrction
userdefined_variables_x13()
```

### Retrieve user defined-output (2/2)

Select the objects and customize estimation function

\footnotesize
```{r,eval=TRUE, include=TRUE}
# version 3
ud<-userdefined_variables_x13()[15:17] # b series
ud
sa_x13_v3_UD<-rjd3x13::x13(y_raw,"RSA5c",userdefined=ud)
sa_x13_v3_UD$user_defined # remainder of the names 
# retrieve the object 
sa_x13_v3_UD$user_defined$decomposition.b1
```


### Plots and data visualisation (1/2) {.allowframebreaks} 

In version 2 three kinds of plots: 
- final (2 types)
- regarima residuals (6 plots)
- SI ratios 

\footnotesize

```{r,eval=TRUE, include=TRUE}
# Version 2
# for class 'final' : 2 types 
plot(sa_x13_v2, type_chart = "sa-trend", first_date = c(2015, 1))
plot(sa_x13_v2, type= "cal-seas-irr",first_date = c(2015, 1))
# regarima
layout(matrix(1:6, 3, 2));plot(sa_x13_v2$regarima,ask = FALSE)
# Plotting SI ratios  
plot(sa_x13_v2$decomposition, first_date = c(2015,1))

```

### Plots and data visualisation (2/2)

In version 3 
- final + NEW "autoplot" layout 
- regarima not available (yet ?)
- SI ratios + NEW ggplot layout 

```{r,eval=TRUE, include=TRUE}
# version 3
# remotes::install_github("AQLT/ggdemetra3",INSTALL_opts = "--no-multiarch")
# library(ggdemetra3)
ggdemetra3::siratioplot(sa_x13_v3)
ggdemetra3::ggsiratioplot(sa_x13_v3)
ggplot2::autoplot(sa_x13_v3)


```


## Customizing specifications

### Customizing specifications: general steps 

To customize a specification you must 
- start with a valid specification, usually one of the defaut specs (equivalent to cloning a spec in GUI)
- create a new spec 
- apply the new spec to a series 

Some differences between v2 and v3

### Customizing specifications: in version 2

Direct parameter modification as arguments of the spec function 
```{r,eval=FALSE, include=TRUE}
# version 2
# changing estimation span, imposing additive model and adding user defined ouliers 
# first create a new spec modifying the previous one 
spec_1<- x13_spec(sa_x13_v2)
spec_2<- x13_spec(spec_1, estimate.from = "2004-01-01",
                  usrdef.outliersEnabled = TRUE,
                             usrdef.outliersType = c("LS", "AO"),
                             usrdef.outliersDate = c("2008-10-01", "2018-01-01"),
                             transform.function = "None") # additive model
# here the reg-arima model will be estimated from  "2004-01-01" 
# the decomposition will be run on the whole span 

# new sa processing
sa_x13_v2_2<-RJDemetra::x13(serie_brute,spec_2)
sa_x13_v2_2$final$series

```


### Customizing specifications: in version 3 

Use direct and specific `set_` functions 
- for the preprocessing step (functions defined in `rjd3modelling`):

`set_arima()`, `set_automodel()`, `set_basic()`, `set_easter()`, `set_estimate()`, `set_outlier()`, `set_tradingdays()`, `set_transform()`, `add_outlier()` and `remove_outlier()`, `add_ramp()` and `remove_ramp()`, `add_usrdefvar()`

- for the decomposition step in X13 (function defined in `rjd3x13`):
 `set_x11()`
 
- for the decomposition step in Tramo-Seats (function defined in `rjd3tramoseats`):
 `set_seats()`
 
- for the benchmarking step (function defined in `rjd3modelling`):
 `set_benchmarking()`

New v3 feature, same options available as in GUI.

### Customizing specifications in version 3: example
```{r,eval=FALSE, include=TRUE}
######### spec custo in v3
# start with default spec 
spec_1 = spec_x13_default("RSA3")
# or start with existing spec (no extraction function needed)
spec_1<-sa_x13_v3_UD$estimation_spec

# set a new spec
## add outliers 
spec_2 = rjd3modelling::add_outlier(spec_1,
                  type = c("AO"), c("2015-01-01", "2010-01-01"))
## set trading days
spec_2<-rjd3modelling::set_tradingdays(spec_2,
    option = "workingdays" )
# set x11 options 
spec_2<-set_x11(spec_2,henderson.filter = 13)
# apply with `fast.x13` (results only)
fast.x13(y,spec_2)

```


### Adding user-defined regressors 

In version 2: regressors added directly to the specification 

In version 3: new notion of "context"
an additionnal concept designed to
- 
- 

### Adding user-defined regressors in v2

```{r,eval=FALSE, include=TRUE}
# defining user defined trading days 
spec_4 <- x13_spec(spec_1,
tradingdays.option = "UserDefined",
tradingdays.test ="None",
usrdef.varEnabled = TRUE,
# the user defined variable will be assigned to the calendar component
usrdef.varType="Calendar",
usrdef.var=td_regs ) # regressors have to be a single or multiple TS 
# new sa processing
sa_x13_v2_4<-x13(serie_brute,spec_4)
# user defined intervention variable  
spec_5 <- x13_spec(spec_1,
                   usrdef.varEnabled = TRUE,
                   # the user defined variable will be assigned to the trend component
                   usrdef.varType="Trend",
                   usrdef.var=x ) # x has to to be a single or multiple TS 
# new sa processing
sa_x13_v2_5<-x13(serie_brute,spec_5)
```

### Adding user-defined regressors in version 3

```{r,eval=FALSE, include=TRUE}
# defining user defined trading days 
td_reg1<- rjd3modelling::td(12, start=start(y_raw),length = length(y_raw),groups = c(1,1,1,1,1,0,0))

context<-rjd3modelling::modelling_context(variables=list(a=xvar))

spec <- rjd3x13::spec_regarima_default(name = "rg3") |>
  rjd3modelling::add_usrdefvar(id = "r.a")

reg_a_estimation<-rjd3x13::regarima(window(ts, start=1985, end=2013),sp,context = context)

# if user_def variable to tren d? how to chose component ?
# regressors have to be added one by one 
```

## Refreshing data 

### Estimation_spec vs result_spec (1/2)

Possibility of refreshing data is new feature of version 3.

In the "sa_model" object generated by the estimation process:

- new handling of spec (no extraction needed as separated)

- notion of 
    - estimation spec (domain spec): set of customizable constraints
    
\footnotesize
```{r, eval=FALSE, include=TRUE}
sa_x13_v3$estimation_spec$regarima$arima
```

    - result spec (or point spec)
\footnotesize    
```{r, eval=FALSE, include=TRUE}
sa_x13_v3$result_spec$regarima$arima
```

### Estimation_spec vs result_spec

- in v2 could only retrieve a (point) result_spec (extracted with x13_spec) 
- in v3 your are able to restimate the result spec inside the domain (estimation spec) freeing constriants on some parameters : just like in GUI

### Steps for refreshing data

```{r,eval=FALSE, include=TRUE}

current_result_spec<-sa_x13_v3$result_spec
current_domain_spec<-sa_x13_v3$estimation_spec

# generate NEW spec for refresh 
refreshed_spec<-x13.refresh(current_spec, # point spec to be refreshed
            current_domain_spec, #domain spec (set of constraints)
            policy = "Outliers",
            period = 12, # monthly series
            start = "2017-01-01",
            end = NULL)

# apply the new spec on new data : y_new= y_raw + 3 months
sa_x13_v3_refresh<-x13(y_new,refreshed_spec)
# what will be the domain spec here ?
# domain spec = point spec ?
```
- Outliers identiication : more flaxible the last ouliers or all outleirs in v2, here the span can be customized 
(Warning: x13.refresh hasn't been thouroughly tested yet)

### Refresh Policies 

- "FreeParameters", 
- "Complete": 
- "Outliers_StochasticComponent", 
- "Outliers",
- "FixedParameters", 
- "FixedAutoRegressiveParameters", 
- "Fixed", 


### User-defined parameters: summary 

- what's new ? 
- whats's missing ?

# SA of High-Frequency data 

### SA of High-Frequency data (1/2)

Specificity: high-frequency data can display multiple and non integer periodicities:

For example a daily serie might display 3 periodicities:
- weekly ($p=7$):  Mondays are alike and different from Sundays (DOW)
- intra-monthly ($p=30.44$):  the last days of each month are different from the first ones (DOM)
- yearly ($p=365.25$):  from on year to another the 15th of June are alike, summer days are alike (DOY)

Two classes of solutions:
- round periodicities (might involve imputing data) (extended STL,..)
- use approximations for fractional backshift powers (extended X13-Arima and Tramo-Seats)

### SA of High-Frequency data (2/2)

Specific tools:  rjd3highfreq and rjd3stl (version 3)
(version 2 : rjdhighfreq)

Different data format: numeric vectors (and NOT TS objects)

- linerarization with fractionnal airline model (correction for calendar effects and outlier detection)

- iterative decomposition (extrended X-11 and Seats) starting with the highest frequency 

See presentation about {rjd3highfreq} (Webinar GitHub Repo)

### Linearization: code template

\footnotesize
```{r, eval=FALSE,include=TRUE}
rjd3highfreq::fractionalAirlineEstimation
                        (df_daily$log_births, # here series in log
                x = q, # q= calendar
                periods = 7, # approx  c(7,365.25)
                ndiff = 2, ar = FALSE, mean = FALSE,
                outliers = c("ao","wo"), 
                # WO compensation, LS not relevant here 
                criticalValue = 0, # computed in the algorithm
                precision = 1e-9, approximateHessian = TRUE)
                    
# calendar regressors can be defined with the {rjd3modelling} package 

```



See {rjd3highfreq} help pages

### Decomposition with extended X-11: code template

\footnotesize 
```{r, eval=FALSE,include=TRUE}
#step 1: p=7
x11.dow<-rjd3highfreq::x11(exp(pre.mult$model$linearized),
        period = 7,                 # DOW pattern
        mul = TRUE,                              
        trend.horizon = 9,  # 1/2 Filter length : not too long vs p
        trend.degree = 3,                         # Polynomial degree
        trend.kernel = "Henderson",               # Kernel function
        trend.asymmetric = "CutAndNormalize",     # Truncation method
        seas.s0 = "S3X9", seas.s1 = "S3X9",       # Seasonal filters
        extreme.lsig = 1.5, extreme.usig = 2.5)   # Sigma-limits
#step 2: p=365.25
x11.doy<- rjd3highfreq::x11(x11.dow$decomposition$sa,  # previous sa
                    period = 365.2425,         # DOY pattern
                    mul = TRUE) #other parameters skipped here
```

See {rjd3highfreq} help pages for more details 


### Decomposition with extended Seats: code template
\footnotesize
```{r, eval=FALSE,include=TRUE}
#step 1: p=7
#step 2: p=365.25
amb.doy <- rjd3highfreq::fractionalAirlineDecomposition(
  amb.dow$decomposition$sa,  # DOW-adjusted linearised data
  period = 365.2425,         # DOY pattern
  sn = FALSE,                # Signal (SA)-noise decomposition 
  stde = FALSE,              # Compute standard deviations
  nbcasts = 0, nfcasts = 0)  # Numbers of back- and forecasts
```

See {rjd3highfreq} help pages for more details


# Generating User-defined auxilary variables 


## calendars

### calendars 

New features of version 3: 

- generating calendars in R (see GUI function in v2)

- generating calendars regressors
    - raw number of days or contrasts
    - long term mean correction or not
    - user-defined groups of days 
    - user-defined contrast days (associated with holidays)


can be done with {rjd3modelling} package


### Creation of a specific calendar

\footnotesize
```{r}
library(rjd3modelling)
fr_cal <- calendar.new()
calendar.holiday(fr_cal, "NEWYEAR")
calendar.holiday(fr_cal, "EASTERMONDAY")
calendar.holiday(fr_cal, "MAYDAY")
calendar.fixedday(fr_cal, month = 5, day = 8,
                  start = "1953-03-20")
# calendar.holiday(fr_cal, "WHITMONDAY") # Equivalent to:
calendar.easter(fr_cal, offset = 61)

calendar.fixedday(fr_cal, month = 7, day = 14)
# calendar.holiday(fr_cal, "ASSUMPTION")
calendar.easter(fr_cal, offset = 61)
calendar.holiday(fr_cal, "ALLSAINTSDAY")
calendar.holiday(fr_cal, "ARMISTICE")
calendar.holiday(fr_cal, "CHRISTMAS")
```


### Creation of a associated regressors  {.allowframebreaks}


Use `holidays()` to get the days of the holidays and `htd()` to get the trading days regressors

\footnotesize
```{r}
holidays(fr_cal, "2020-12-24", 10,single = T)
s = ts(0, start = 2020, end = c(2020, 11), frequency = 12)
# Trading-days regressors (each day has a different effect, sunday as contrasts)
td_reg <- htd(fr_cal, s = s, groups = c(1, 2, 3, 4, 5, 6, 0))
# Working-days regressors (Monday = ... = Friday; Saturday = Sunday = contrasts)
wd_reg <- htd(fr_cal, s = s, groups = c(1, 1, 1, 1, 1, 0, 0))
# Monday = ... = Friday; Saturday; Sunday = contrasts
wd_reg <- htd(fr_cal, s = s, groups = c(1, 1, 1, 1, 1, 2, 0))
wd_reg
# Monday = ... = Wednesday; Thursday; Friday = contrasts
wd_reg2<- htd(fr_cal, s = s, groups = c(1, 1, 1, 2, 0, 1, 1))
wd_reg2
```


## Outliers and intervention variables 

### Outliers and intervention variables 

New feature of version 3 allows to create: 

- outliers regressors (AO, LS, TC, SO, Ramp (quadratic to be added)
- trigonometric variables

### Example of outliers {.allowframebreaks} 

\footnotesize

```{r outplot}
s = ts(0, start = 2000, end = 2005, frequency = 12)
ao = ao.variable(s = s, date = "2001-03-01")
ls = ls.variable(s = s, date = "2001-01-01")
tc = tc.variable(s = s, date = "2001-01-01", rate = 0.7)
so = so.variable(s = s, date = "2003-05-01")
ramp = ramp.variable(s = s, range = c("2001-01-01","2001-12-01"))
plot(ts.union(ao, ls, tc, so, ramp), plot.type = "single",
     col = c("red","lightgreen","orange","blue","black"))
```


# Time series tools 

### Time series tools: NEW features in version 3

The spirit of version 3 is to offer more tools from JDemetra+ libraries such as:

- tests (seasonality, normality, randomness, residual td effects) (rjd3tookit, rjd3modelling; rjd3sa)

- autocorrelation functions (irjd3toolkit), incl partial and inverse

- arima model estimation and decomposition (rjd3modelling)

- aggregation to higher frequency (`rjd3toolkit::aggregate()`)


More flexibilty for the user as they can be applied any time not just as part of an SA porcessing.

Some of might also be available in other R packages. Arima model estimation is notoriously faster than other R functions.


### Testing for seasonality

In rjd3sa:

- Canova-Hansen (`seasonality.canovahansen()`)

- X-12 combined test (`seasonality.combined()`)

- F-test on seasonal dummies (`seasonality.f()`)

- Friedman Seasonality Test (`seasonality.friedman()`)

- Kruskall-Wallis Seasonality Test (`seasonality.kruskalwallis()`)

- Periodogram Seasonality Test (`seasonality.periodogram()`)

- QS Seasonality Test (`seasonality.qs()`)


### Testing for seasonality: examples {.allowframebreaks} 

(Always correct the trend and remove the mean before seasonality tests)

\footnotesize
```{r}
library(rjd3sa)
y = diff(rjd3toolkit::ABS$X0.2.09.10.M, 1); y = y - mean(y)
seasonality.f(y, 12)
seasonality.friedman(y, 12)
seasonality.kruskalwallis(y, 12)
seasonality.combined(y, 12)
```



### Arima estimation 


```{r, include=TRUE, eval=FALSE}
# JD+
print(system.time(for (i in 1:1000) {  j<-rjd3modelling::sarima.estimate(log(rjd3toolkit::ABS$X0.2.09.10.M), order=c(2,1,1), seasonal = list(order=c(0,1,1), period=12))}))

#utilisateur     système      écoulé 
#      4.98        0.37        4.63 

#R-native
print(system.time(for (i in 1:1000) {  r<-arima(log(rjd3toolkit::ABS$X0.2.09.10.M), order=c(2,1,1), seasonal = list(order=c(0,1,1), period=12))}))
print(j$likelihood )
print(r)

# utilisateur     système      écoulé 
#     158.74        0.23      160.49 

```


# Conclusion 

### Conclusion on SA in R

What has v3 brought to the table ?





